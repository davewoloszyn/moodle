{"version":3,"file":"embedhandler.min.js","sources":["../../src/embed/embedhandler.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny media plugin media handler class for embed.\n *\n * @module      tiny_media/embed/embedhandler\n * @copyright   2024 Stevani Andolo <stevani@hotmail.com.au>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport * as ModalEvents from 'core/modal_events';\nimport Selectors from \"../selectors\";\nimport Templates from 'core/templates';\nimport {EmbedInsert} from './embedinsert';\nimport {\n    insertMediaTemplateContext,\n    prepareMoodleLang,\n    getHelpStrings,\n    getMoodleLangObj,\n    getLinkBasedUrl,\n    setPropertiesFromData,\n} from \"./embedhelpers\";\nimport {\n    body,\n    footer,\n    isValidUrl,\n    hideElements,\n    convertStringUrlToObject,\n    stopMediaLoading,\n    createUrlParams,\n} from '../helpers';\nimport {displayFilepicker} from 'editor_tiny/utils';\n\nexport class EmbedHandler {\n\n    constructor(data) {\n        setPropertiesFromData(this, data);\n    }\n\n    /**\n     * Load the media insert dialogue.\n     *\n     * @param {object} templateContext Object template context\n     */\n    loadTemplatePromise = (templateContext) => {\n        templateContext.elementid = this.editor.id;\n        templateContext.bodyTemplate = Selectors.EMBED.template.body.insertMediaBody;\n        templateContext.footerTemplate = Selectors.EMBED.template.footer.insertMediaFooter;\n        templateContext.selector = 'EMBED';\n\n        Promise.all([body(templateContext, this.root), footer(templateContext, this.root)])\n            .then(() => {\n                const mediaInsert = new EmbedInsert(this);\n                mediaInsert.init();\n                return;\n            })\n            .catch(error => {\n                window.console.log(error);\n            });\n    };\n\n    /**\n     * Loads the media preview dialogue.\n     *\n     * @param {object} mediaDetails Object of mediaDetails\n     * @param {object} templateContext Object of template context\n     */\n    loadMediaDetails = async(mediaDetails, templateContext) => {\n        Promise.all([body(templateContext, this.root), footer(templateContext, this.root)])\n            .then(() => {\n                if (this.mediaData) { // It came from mediaThumbnail and we should kill uploadThumbnailModal modal.\n                    this.currentModal.uploadThumbnailModal.destroy();\n                    const currentModal = this.currentModal.insertMediaModal;\n                    this.currentModal = currentModal.insertMediaModal;\n                }\n                mediaDetails.init();\n                return;\n            }).then(() => {\n                if (!this.mediaData) { // It came from mediaThumbnail and we did not init startMediaLoading from there.\n                    stopMediaLoading(this.root, 'EMBED');\n                }\n                return;\n            })\n            .catch(error => {\n                if (!this.mediaData) { // It came from mediaThumbnail and we did not init startMediaLoading from there.\n                    stopMediaLoading(this.root, 'EMBED');\n                }\n                window.console.log(error);\n            });\n    };\n\n    /**\n     * Get selected media data.\n     *\n     * @returns {null|object}\n     */\n    getMediumProperties = () => {\n        const boolAttr = (elem, attr) => {\n            // As explained in MDL-64175, some OS (like Ubuntu), are removing the value for these attributes.\n            // So in order to check if attr=\"true\", we need to check if the attribute exists and if the value is empty or true.\n            return (elem.hasAttribute(attr) && (elem.getAttribute(attr) || elem.getAttribute(attr) === ''));\n        };\n\n        const medium = this.selectedMedia;\n        if (!medium) {\n            return null;\n        }\n\n        const isLink = (this.mediaType === 'link');\n        if (isLink) {\n            const urlParams = convertStringUrlToObject(medium.href);\n            const mediaData = {\n                type: this.mediaType,\n                title: medium.textContent.trim(),\n            };\n\n            for (const param in urlParams) {\n                let prop = param;\n                if (param === 'mute') {\n                    prop = 'muted';\n                }\n                const isTrue = (urlParams[param] === 'true') || (urlParams[param] === '1');\n                mediaData[prop] = isTrue;\n            }\n            return mediaData;\n        } else {\n            const tracks = {\n                subtitles: [],\n                captions: [],\n                descriptions: [],\n                chapters: [],\n                metadata: []\n            };\n            const sources = [];\n\n            medium.querySelectorAll('track').forEach((track) => {\n                tracks[track.getAttribute('kind')].push({\n                    src: track.getAttribute('src'),\n                    srclang: track.getAttribute('srclang'),\n                    label: track.getAttribute('label'),\n                    defaultTrack: boolAttr(track, 'default')\n                });\n            });\n\n            medium.querySelectorAll('source').forEach((source) => {\n                sources.push(source.src);\n            });\n            const title = medium.getAttribute('title');\n\n            return {\n                type: this.mediaType,\n                sources,\n                poster: medium.getAttribute('poster'),\n                title: title ? title.trim() : false,\n                width: medium.getAttribute('width'),\n                height: medium.getAttribute('height'),\n                autoplay: boolAttr(medium, 'autoplay'),\n                loop: boolAttr(medium, 'loop'),\n                muted: boolAttr(medium, 'muted'),\n                controls: boolAttr(medium, 'controls'),\n                tracks,\n            };\n        }\n    };\n\n    /**\n     * Get selected media data.\n     *\n     * @returns {object}\n     */\n    getCurrentEmbedData = () => {\n        const properties = this.getMediumProperties();\n        if (!properties) {\n            return {};\n        }\n\n        const processedProperties = {};\n        processedProperties.media = properties;\n        processedProperties.link = false;\n\n        return processedProperties;\n    };\n\n    /**\n     * Get help strings for media subtitles and captions.\n     *\n     * @returns {null|object}\n     */\n    getHelpStrings = async() => {\n        if (!this.helpStrings) {\n            this.helpStrings = await getHelpStrings();\n        }\n\n        return this.helpStrings;\n    };\n\n    /**\n     * Set template context for insert media dialogue.\n     *\n     * @param {object} data Object of media data\n     * @returns {object}\n     */\n    getTemplateContext = async(data) => {\n        const languages = prepareMoodleLang(this.editor);\n        const helpIcons = Array.from(Object.entries(await this.getHelpStrings())).forEach(([key, text]) => {\n            data[`${key.toLowerCase()}helpicon`] = {text};\n        });\n\n        return Object.assign({}, {\n            elementid: this.editor.getElement().id,\n            showFilePickerTrack: this.canShowFilePickerTrack,\n            langsInstalled: languages.installed,\n            langsAvailable: languages.available,\n            media: true,\n            isUpdating: this.isUpdating,\n        }, data, helpIcons);\n    };\n\n    /**\n     * Set and get media template context.\n     *\n     * @param {null|object} data Null or object of media data\n     * @returns {Promise<object>} A promise that resolves template context.\n     */\n    getMediaTemplateContext = async(data = null) => {\n        if (!data) {\n            data = Object.assign({}, this.getCurrentEmbedData());\n        }\n        this.isUpdating = Object.keys(data).length !== 0;\n        return await this.getTemplateContext(data);\n    };\n\n    /**\n     * Reset the media insert modal form.\n     */\n    resetUploadForm = () => {\n        this.mediaType = null; // Set to null to be set again.\n        this.loadTemplatePromise(insertMediaTemplateContext(this));\n    };\n\n    /**\n     * Load the media preview dialogue.\n     *\n     * @param {string} url String of media url\n     */\n    loadMediaPreview = (url) => {\n        (new EmbedInsert(this)).loadMediaPreview(url);\n    };\n\n    /**\n     * Handles changes in the media URL input field and loads a preview of the media if the URL has changed.\n     */\n    urlChanged() {\n        hideElements(Selectors.EMBED.elements.urlWarning, this.root);\n        const url = this.root.querySelector(Selectors.EMBED.elements.fromUrl).value;\n        if (url && url !== this.currentUrl) {\n            this.loadMediaPreview(url);\n        }\n    }\n\n    /**\n     * Callback for file picker that previews the media or add the captions and subtitles.\n     *\n     * @param {object} params Object of media url and etc\n     * @param {html} element Selected element.\n     * @param {string} fpType Caption type.\n     */\n    trackFilePickerCallback(params, element, fpType) {\n        if (params.url !== '') {\n            const tabPane = element.closest('.tab-pane');\n            if (tabPane) {\n                element.closest(Selectors.EMBED.elements.source).querySelector(Selectors.EMBED.elements.url).value = params.url;\n\n                if (fpType === 'subtitle') {\n                    // If the file is subtitle file. We need to match the language and label for that file.\n                    const subtitleLang = params.file.split('.vtt')[0].split('-').slice(-1)[0];\n                    const langObj = getMoodleLangObj(subtitleLang, this.editor);\n                    if (langObj) {\n                        const track = element.closest(Selectors.EMBED.elements.track);\n                        track.querySelector(Selectors.EMBED.elements.trackLabel).value = langObj.lang.trim();\n                        track.querySelector(Selectors.EMBED.elements.trackLang).value = langObj.code;\n                    }\n                }\n            } else {\n                this.loadMediaPreview(params.url);\n            }\n        }\n    }\n\n    addTrackComponent(element) {\n        const trackElement = element.closest(Selectors.EMBED.elements.track);\n        const clone = trackElement.cloneNode(true);\n\n        trackElement.querySelector('.removecomponent-wrapper').classList.remove('hidden');\n        trackElement.querySelector('.addcomponent-wrapper').classList.add('hidden');\n        trackElement.parentNode.insertBefore(clone, trackElement.nextSibling);\n    }\n\n    removeTrackComponent(element) {\n        const sourceElement = element.closest(Selectors.EMBED.elements.track);\n        sourceElement.remove();\n    }\n\n    /**\n     * Get captions/subtitles type.\n     *\n     * @param {html} tabPane\n     * @returns {string}\n     */\n    getTrackTypeFromTabPane = (tabPane) => {\n        return tabPane.getAttribute('data-track-kind');\n    };\n\n    /**\n     * Get picker type based on the selected element.\n     *\n     * @param {html} element Selected element\n     * @returns {string}\n     */\n    getFilePickerTypeFromElement = (element) => {\n        if (element.closest(Selectors.EMBED.elements.posterSource)) {\n            return 'image';\n        }\n        if (element.closest(Selectors.EMBED.elements.trackSource)) {\n            return 'subtitle';\n        }\n\n        return 'media';\n    };\n\n    /**\n     * Handle click events.\n     *\n     * @param {html} e Selected element\n     */\n    clickHandler = async(e) => {\n        const element = e.target;\n\n        const mediaBrowser = element.closest(Selectors.EMBED.actions.mediaBrowser);\n        if (mediaBrowser) {\n            e.preventDefault();\n            const fpType = this.getFilePickerTypeFromElement(element);\n            const params = await displayFilepicker(this.editor, fpType);\n            this.trackFilePickerCallback(params, element, fpType);\n        }\n\n        const addUrlEle = e.target.closest(Selectors.EMBED.actions.addUrl);\n        if (addUrlEle) {\n            this.urlChanged();\n        }\n\n        const addComponentTrackAction = element.closest(Selectors.EMBED.elements.track + ' .addcomponent');\n        if (addComponentTrackAction) {\n            e.preventDefault();\n            this.addTrackComponent(element);\n        }\n\n        const removeComponentTrackAction = element.closest(Selectors.EMBED.elements.track + ' .removecomponent');\n        if (removeComponentTrackAction) {\n            e.preventDefault();\n            this.removeTrackComponent(element);\n        }\n\n        // Only allow one track per tab to be selected as \"default\".\n        const trackDefaultAction = element.closest(Selectors.EMBED.elements.trackDefault);\n        if (trackDefaultAction && trackDefaultAction.checked) {\n            const getKind = (el) => this.getTrackTypeFromTabPane(el.parentElement.closest('.tab-pane'));\n\n            element.parentElement\n                .closest('.tab-content')\n                .querySelectorAll(Selectors.EMBED.elements.trackDefault)\n                .forEach((select) => {\n                    if (select !== element && getKind(element) === getKind(select)) {\n                        select.checked = false;\n                    }\n                });\n        }\n    };\n\n    /**\n     * Enables or disables the URL-related buttons in the footer based on the current URL and input value.\n     *\n     * @param {html} input Url input field\n     */\n    toggleUrlButton(input) {\n        const url = input.value;\n        const addUrl = this.root.querySelector(Selectors.EMBED.actions.addUrl);\n        addUrl.disabled = !(url !== \"\" && isValidUrl(url));\n    }\n\n    /**\n     * Get media html to be inserted or updated into tiny.\n     *\n     * @param {html} form Selected element\n     * @returns {string} String of html\n     */\n    getMediaHTML = (form) => {\n        let mediumType = this.root.querySelector(Selectors.EMBED.elements.previewClass).nodeName.toLowerCase();\n        mediumType = (mediumType === 'iframe') ? 'link' : mediumType;\n        const tabContent = form.querySelector('.tab-content');\n        const callback = 'getMediaHTML' + mediumType[0].toUpperCase() + mediumType.substr(1);\n        return this[callback](tabContent);\n    };\n\n    /**\n     * Get media as link.\n     *\n     * @returns {string} String of html\n     */\n    getMediaHTMLLink = () => {\n        const details = document.querySelector(Selectors.EMBED.elements.mediaDetailsBody);\n        const url = details.querySelector(Selectors.EMBED.elements.preview).src ?? null;\n        const urlParamString = createUrlParams({\n            controls: details.querySelector(Selectors.EMBED.elements.mediaControl).checked ? 1 : 0,\n            autoplay: details.querySelector(Selectors.EMBED.elements.mediaAutoplay).checked ? 1 : 0,\n            mute: details.querySelector(Selectors.EMBED.elements.mediaMute).checked ? 1 : 0,\n        });\n        const name = details.querySelector(Selectors.EMBED.elements.title).value || false;\n        const context = {\n            url: getLinkBasedUrl(url) + urlParamString,\n            name: name ? name.trim() : false,\n        };\n\n        return context.url ? Templates.renderForPromise('tiny_media/embed/embed_media_link', context) : '';\n    };\n\n    /**\n     * Get media as video.\n     *\n     * @param {html} tab Selected element\n     * @returns {string} String of html.\n     */\n    getMediaHTMLVideo = (tab) => {\n        const details = document.querySelector(Selectors.EMBED.elements.mediaDetailsBody);\n        const context = this.getContextForMediaHTML(tab, details);\n        context.width = details.querySelector(Selectors.EMBED.elements.width).value || false;\n        context.height = details.querySelector(Selectors.EMBED.elements.height).value || false;\n        context.poster = details.querySelector(Selectors.EMBED.elements.videoTag).poster || false;\n        return context.sources ? Templates.renderForPromise('tiny_media/embed/embed_media_video', context) : '';\n    };\n\n    /**\n     * Get media as audio.\n     *\n     * @param {html} tab Selected element\n     * @returns {string} String of html.\n     */\n    getMediaHTMLAudio = (tab) => {\n        const details = document.querySelector(Selectors.EMBED.elements.mediaDetailsBody);\n        const context = this.getContextForMediaHTML(tab, details);\n        return context.sources.length ? Templates.renderForPromise('tiny_media/embed/embed_media_audio', context) : '';\n    };\n\n    /**\n     * Get previewed media data.\n     *\n     * @param {html} tab Selected element\n     * @param {html} details Selected element\n     * @returns {object}\n     */\n    getContextForMediaHTML = (tab, details) => {\n        const tracks = Array.from(tab.querySelectorAll(Selectors.EMBED.elements.track)).map(track => ({\n            track: track.querySelector(Selectors.EMBED.elements.trackSource + ' ' + Selectors.EMBED.elements.url).value,\n            kind: this.getTrackTypeFromTabPane(track.closest('.tab-pane')),\n            label: track.querySelector(Selectors.EMBED.elements.trackLabel).value ||\n                track.querySelector(Selectors.EMBED.elements.trackLang).value,\n            srclang: track.querySelector(Selectors.EMBED.elements.trackLang).value,\n            defaultTrack: track.querySelector(Selectors.EMBED.elements.trackDefault).checked ? \"true\" : null\n        })).filter((track) => !!track.track);\n\n        const sources = details.querySelector(Selectors.EMBED.elements.preview).src ?? null;\n        const title = details.querySelector(Selectors.EMBED.elements.title).value;\n\n        return {\n            sources,\n            description: tab.querySelector(Selectors.EMBED.elements.url).value || false,\n            tracks,\n            showControls: details.querySelector(Selectors.EMBED.elements.mediaControl).checked,\n            autoplay: details.querySelector(Selectors.EMBED.elements.mediaAutoplay).checked,\n            muted: details.querySelector(Selectors.EMBED.elements.mediaMute).checked,\n            loop: details.querySelector(Selectors.EMBED.elements.mediaLoop).checked,\n            title: title !== '' ? title.trim() : false,\n        };\n    };\n\n    /**\n     * Handle the insert/update media in tiny editor.\n     *\n     * @param {event} event\n     * @param {object} modal Object of current modal\n     */\n    handleDialogueSubmission = async(event, modal) => {\n        const {html} = await this.getMediaHTML(modal.getRoot()[0]);\n        if (html) {\n            if (this.isUpdating) {\n                this.selectedMedia.outerHTML = html;\n                this.isUpdating = false;\n            } else {\n                this.editor.insertContent(html);\n            }\n        }\n    };\n\n    registerEventListeners = async(modal) => {\n        await modal.getBody();\n        const $root = modal.getRoot();\n        const root = $root[0];\n        if (this.canShowFilePickerTrack) {\n            root.addEventListener('click', this.clickHandler.bind(this));\n        }\n\n        root.addEventListener('input', (e) => {\n            const urlEle = e.target.closest(Selectors.EMBED.elements.fromUrl);\n            if (urlEle) {\n                this.toggleUrlButton(urlEle);\n            }\n        });\n\n        $root.on(ModalEvents.save, this.handleDialogueSubmission.bind(this));\n        $root.on(ModalEvents.hidden, () => {\n            this.currentModal.destroy();\n        });\n\n        $root.on(ModalEvents.shown, () => {\n            this.root.querySelectorAll(Selectors.EMBED.elements.trackLang).forEach((dropdown) => {\n                const defaultVal = dropdown.getAttribute('data-value');\n                if (defaultVal) {\n                    dropdown.value = defaultVal;\n                }\n            });\n        });\n    };\n}\n"],"names":["constructor","data","templateContext","elementid","this","editor","id","bodyTemplate","Selectors","EMBED","template","body","insertMediaBody","footerTemplate","footer","insertMediaFooter","selector","Promise","all","root","then","EmbedInsert","init","catch","error","window","console","log","async","mediaDetails","mediaData","currentModal","uploadThumbnailModal","destroy","insertMediaModal","boolAttr","elem","attr","hasAttribute","getAttribute","medium","selectedMedia","mediaType","urlParams","href","type","title","textContent","trim","param","prop","isTrue","tracks","subtitles","captions","descriptions","chapters","metadata","sources","querySelectorAll","forEach","track","push","src","srclang","label","defaultTrack","source","poster","width","height","autoplay","loop","muted","controls","properties","getMediumProperties","processedProperties","media","link","helpStrings","languages","helpIcons","Array","from","Object","entries","getHelpStrings","_ref","key","text","toLowerCase","assign","getElement","showFilePickerTrack","canShowFilePickerTrack","langsInstalled","installed","langsAvailable","available","isUpdating","_this","getCurrentEmbedData","keys","length","getTemplateContext","loadTemplatePromise","url","loadMediaPreview","tabPane","element","closest","elements","posterSource","trackSource","e","target","actions","mediaBrowser","preventDefault","fpType","getFilePickerTypeFromElement","params","trackFilePickerCallback","addUrl","urlChanged","addTrackComponent","removeTrackComponent","trackDefaultAction","trackDefault","checked","getKind","el","getTrackTypeFromTabPane","parentElement","select","form","mediumType","querySelector","previewClass","nodeName","tabContent","toUpperCase","substr","details","document","mediaDetailsBody","preview","urlParamString","mediaControl","mediaAutoplay","mute","mediaMute","name","value","context","Templates","renderForPromise","tab","getContextForMediaHTML","videoTag","map","kind","trackLabel","trackLang","filter","description","showControls","mediaLoop","event","modal","html","getMediaHTML","getRoot","outerHTML","insertContent","getBody","$root","addEventListener","clickHandler","bind","urlEle","fromUrl","toggleUrlButton","on","ModalEvents","save","handleDialogueSubmission","hidden","shown","dropdown","defaultVal","urlWarning","currentUrl","subtitleLang","file","split","slice","langObj","lang","code","trackElement","clone","cloneNode","classList","remove","add","parentNode","insertBefore","nextSibling","input","disabled"],"mappings":"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"}